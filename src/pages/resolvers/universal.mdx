import { InterfaceDetails } from '../../components/InterfaceDetails'
import { universalresolver_methods } from '../../data/universal-resolver'

# Universal Resolver [A swiss army knife for resolution.]

## Overview

The Universal Resolver is a smart contract that handles the work of resolving a name entirely onchain, making it possible to make a single smart contract call to resolve an ENS name.

This is the recommended way to implement ENS resolution in low-level libraries like [ethers](https://ethers.org/) and [viem](https://viem.sh). Application developers typically don't need to use it directly.

## Implementation Guide

The universal resolver is the only ENS smart contract that should to be hardcoded into a library for resolution. You can find the [latest deployment addresses here](/learn/deployments).

### Forward Resolution

To resolve one or more records for a name, use the `resolve(bytes name, bytes data)` method which returns `(bytes data, address resolver)`.

The `name` argument is the [DNS-encoded](/resolution/names#dns) version of the name. Make sure to [normalize](/resolution/names#normalize) the name first, as well! For example, given the name `My.Name.eth`:

1. Normalize:
   - `My.Name.eth` -> `my.name.eth`
2. DNS Encode:
   - `my.name.eth` -> `0x026d79046e616d650365746800`

The `data` argument is a single ABI-encoded call to the resolver for that name, or a multicall encoded via the following interface:

```solidity
interface IMulticallable {
  function multicall(bytes[] calldata data) external view returns (bytes[] memory results);
}
```

For example, if you want to resolve the ETH address and description text record for `gregskril.eth`, your logic to generate the `data` parameter would look something like this:

```js
import { namehash, normalize } from 'viem/ens'
import { encodeFunctionData, parseAbi } from 'viem/utils'

const simpleResolverAbi = parseAbi([
  'function addr(bytes32 node) view returns (address)',
  'function text(bytes32 node, string key) view returns (string)',
])

const multicallAbi = parseAbi([
  'function multicall(bytes[] data) returns (bytes[] results)',
])

const name = normalize('gregskril.eth')
const node = namehash(name)

const resolverCalls = [
  {
    abi: simpleResolverAbi,
    functionName: 'addr',
    args: [node],
  },
  {
    abi: simpleResolverAbi,
    functionName: 'text',
    args: [node, 'description'],
  },
]

const data = encodeFunctionData({
  abi: multicallAbi,
  functionName: 'multicall',
  args: [resolverCalls.map((call) => encodeFunctionData(call))],
})
```

Learn about [standard resolver methods](/resolvers/interfaces) for ABI-encoding that should be added to `simpleResolverAbi` in production.

The response you'll get back from `resolve` will have to be decoded against the multicall ABI, then further decoded against the simple resolver ABI. This results in the ETH address and description text record value. The rest of the logic would look something like this:

```js
import { createPublicClient, http, toHex } from 'viem'
import { mainnet } from 'viem/chains'
import { packetToBytes } from 'viem/ens'

// ...adding from the above example

const dnsEncodedName = toHex(packetToBytes(name))

const universalResolverAbi = parseAbi([
  'error ResolverNotFound(bytes name)',
  'error ResolverNotContract(bytes name, address resolver)',
  'error UnsupportedResolverProfile(bytes4 selector)',
  'error ResolverError(bytes errorData)',
  'error ReverseAddressMismatch(string primary, bytes primaryAddress)',
  'error HttpError(uint16 status, string message)',
  'function resolve(bytes name, bytes data) returns (bytes result, address resolver)',
  'function reverse(bytes lookupAddress, uint256 coinType) returns (string primary, address resolver, address reverseResolver)',
])

const client = createPublicClient({
  chain: mainnet,
  transport: http(),
})

const resolveRes = await client.readContract({
  abi: universalResolverAbi,
  address: '0xaBd80E8a13596fEeA40Fd26fD6a24c3fe76F05fB',
  functionName: 'resolve',
  args: [dnsEncodedName, data],
})

const decodedMulticall = decodeFunctionResult({
  abi: multicallAbi,
  functionName: 'multicall',
  data: resolveRes[0],
})

const decodedRes = decodedMulticall.map((res, i) =>
  decodeFunctionResult({
    abi: simpleResolverAbi,
    functionName: resolverCalls[i].functionName,
    data: res,
  })
)

// decodedRes[0] = "0x179A862703a4adfb29896552DF9e307980D19285"
// decodedRes[1] = "I like baking and building apps on web3 protocols."
```

### Reverse Resolution

To reverse-resolve an address to an ENS name (go from address to name), call the `reverse (bytes lookupAddress, uint256 coinType)` method which returns `(string primary, address resolver, address reverseResolver)`.

The `lookupAddress` argument is the Ethereum address of the account you want to fetch the primary name for. The `coinType` argument defines the chain you'd like to fetch the reverse record from. See [Multichain Addresses](/web/resolution#multichain-addresses) for more information about the `coinType` argument.

`reverse` internally checks that the name forward resolves to the address you're looking up, so your implementation doesn't need to do any additional checks and should be quite straightforward. It might look something like this:

```ts
import { createPublicClient, http, parseAbi } from 'viem'
import { mainnet } from 'viem/chains'

const address = '0xb8c2C29ee19D8307cb7255e1Cd9CbDE883A267d5'

const universalResolverAbi = parseAbi([
  'error ResolverNotFound(bytes name)',
  'error ResolverNotContract(bytes name, address resolver)',
  'error UnsupportedResolverProfile(bytes4 selector)',
  'error ResolverError(bytes errorData)',
  'error ReverseAddressMismatch(string primary, bytes primaryAddress)',
  'error HttpError(uint16 status, string message)',
  'function resolve(bytes name, bytes data) view returns (bytes result, address resolver)',
  'function reverse(bytes lookupAddress, uint256 coinType) view returns (string primary, address resolver, address reverseResolver)',
])

const client = createPublicClient({
  chain: mainnet,
  transport: http(),
})

const [primaryName] = await client.readContract({
  abi: universalResolverAbi,
  address: '0xaBd80E8a13596fEeA40Fd26fD6a24c3fe76F05fB',
  functionName: 'reverse',
  args: [address, 60n],
})

// primaryName = "nick.eth"
```

### CCIP Read Gateways

{/* I need help on this part to explain Batch Gateway Offchain Lookup Protocol */}
